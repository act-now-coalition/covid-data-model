from typing import Dict
import tabulate
import pathlib


# Template line that exists in the API README.V1.tmpl.md file.
# Replaced by
README_TEMPLATE = "####api_descriptions####"


SCHEMA_DOC_TEMPLATE = """
### {title}
{description}

{table_output}
"""

DISCLAIMER = """
<!--- NOTE: This file was autogenerated. Do not make direct changes. --->
<!--- Make changes in api/README.V1.tmpl.md and run `./run.py api update-schemas` --->
"""


def _model_from_ref(ref: str, all_schemas: Dict[str, Dict]):
    """Gets model description from simple reference.

    Only matches basic JSON Schema references that exist in `all_schemas['description']`.

    Args:
        ref: Reference to model.
        all_schemas: JSON Schema to find references in.

    Returns: Model description for ref.
    """
    _, key, value = ref.split("/")
    return all_schemas[key][value]


def _generate_property_list(properties, all_schemas):
    rows = []
    for name, prop in properties.items():
        title = None
        if "$ref" in prop:
            ref_model = _model_from_ref(prop["$ref"], all_schemas)
            obj_type = ref_model["title"]
            row = {
                "name": name,
                "type": f"[{obj_type}](#{obj_type})",
                "description": ref_model.get("description", ""),
            }
        else:
            obj_type = prop.get("type")

            # Look for cases where data missing type data, but has one schema
            # that data matches and pull type from associated object.
            if not obj_type and "allOf" in prop and len(prop["allOf"]) == 1:
                ref = prop["allOf"][0].get("$ref")
                if ref:
                    ref_model = _model_from_ref(ref, all_schemas)
                    obj_type = ref_model["title"]
                    obj_type = f"[{obj_type}](#{obj_type})"

            row = {
                "name": name,
                "type": obj_type,
                "description": prop.get("description", ""),
            }
        rows.append(row)
    return rows


def schema_to_md(schema, all_schemas) -> str:
    """Generates Markdown overview for a single schema.

    Args:
        schema: JSON Schema for an API Model.
        all_schemas: JSON Schema of all API Model Schemas.

    Returns: Markdown description of schema.
    """
    title = schema["title"]
    description = schema.get("description", "")
    rows = []

    if schema.get("type") == "array":
        ref_model = _model_from_ref(schema["items"]["$ref"], all_schemas)
        return SCHEMA_DOC_TEMPLATE.format(
            title=title,
            description=description,
            table_output=f"List of [{ref_model['title']}](#{ref_model['title']})",
        )

    table_rows = _generate_property_list(schema["properties"], all_schemas)
    keys = {key: key for key in table_rows[0]}
    table_output = tabulate.tabulate(table_rows, keys, tablefmt="github")
    return SCHEMA_DOC_TEMPLATE.format(
        title=title, description=description, table_output=table_output
    )


def generate_markdown_for_schema_definitions(schema: dict) -> str:

    all_text = ""
    for schema_definition in schema["definitions"].values():
        all_text += schema_to_md(schema_definition, schema) or ""

    return all_text


def generate_api_readme_from_template(
    input_path: pathlib.Path, output_path: pathlib.Path, text, template=README_TEMPLATE
):
    input_text = input_path.read_text()
    input_text = input_text.replace(template, text)
    input_text = DISCLAIMER + input_text
    output_path.write_text(input_text)
